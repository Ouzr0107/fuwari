---
title: 数字图像处理技术记录
published: 2025-11-27
description: '晚上就要讲这个的 PPT 了，我还是啥也不知道'
image: ''
tags: [技术, 课程]
category: '学习'
draft: false 
lang: ''
---

为了防止晚上的讲解太离谱，我准备再看看用到的相关技术（虽然有可能都轮不到我，那么多人都要讲哎！）。

## LAB 色彩空间

LAB 代表明度、A、B。设计为感知均匀，意味着小的变化对应小的感知变化。其目标是模仿人类看和解释颜色的方法。

L (亮度): 图像的亮度（0–100 范围，但在 OpenCV 中映射到 0–255）。
A (绿–红): 正值表示红色，负值表示绿色。
B (蓝–黄): 正值表示黄色，负值表示蓝色。

![LAB 色彩空间](https://github.com/Ouzr0107/picx-images-hosting/raw/master/lab.2a5j0k3ruu.webp)

## 高斯模糊

高斯模糊（英语：Gaussian Blur），也叫高斯平滑，是在Adobe Photoshop、GIMP以及Paint.NET等图像处理软件中广泛使用的处理效果，通常用它来减少图像噪声以及降低细节层次。

高斯模糊是一种图像模糊滤波器，它用正态分布计算图像中每个像素的变换。N维空间正态分布方程为

$$G(r)=\frac{1}{\sqrt{2\pi\sigma^{2}}{}^{N}}e^{-r^{2}/(2\sigma^{2})}$$

在二维空间定义为

$$G(u,v)=\frac{1}{2\pi\sigma^{2}}e^{-(u^{2}+v^{2})/(2\sigma^{2})}$$

![正态分布图像](https://github.com/Ouzr0107/picx-images-hosting/raw/master/image.7eh7puirtm.png)

计算平均值的时候，我们只需要将"中心点"作为原点，其他点按照其在正态曲线上的位置，分配权重，就可以得到一个加权平均值。

假定中心点的坐标是（0,0），那么距离它最近的8个点的坐标如下：

![坐标](https://github.com/Ouzr0107/picx-images-hosting/raw/master/bg2012111410.szdyto0x3.png)

为了计算权重矩阵，需要自己设定σ模糊半径（指的就是你中心点与周围像素的距离取值后所确定的值）。我们来定σ=1.5，则模糊半径为1.5的权重矩阵如下：

![初始权重](https://github.com/Ouzr0107/picx-images-hosting/raw/master/bg2012111411.73udwpcuqu.png)

为了完成权重矩阵的归一化，我们还需要对上面的各值进行除于他们的总值的计算，目的是让最终的图像通道的权重总值为1，不然使用总值大于1的卷积滤镜会让图像偏亮，小于1的卷积滤镜会让图像偏暗。这九个权重值的总和等于0.4787147，所以我们直接进行除法运算，得到以下的权重矩阵。
这个权重矩阵就是我们最终得到的高斯核！！即滤波器矩阵

![归一化](https://github.com/Ouzr0107/picx-images-hosting/raw/master/bg2012111412.wizwjh3mu.png)

有了权重矩阵，就可以计算高斯模糊的值了。
假设现有9个像素点，灰度值（0-255）如下：

![灰度值](https://github.com/Ouzr0107/picx-images-hosting/raw/master/bg2012111413.6m4c84c52l.png)

每个点乘以自己的权重值得到

![乘以权重](https://github.com/Ouzr0107/picx-images-hosting/raw/master/bg2012111416.102lu9a6cm.png)

将这9个值加起来，就是中心点的高斯模糊的值。

对所有点重复这个过程，就得到了高斯模糊后的图像。如果原图是彩色图片，可以对RGB三个通道分别做高斯模糊。

参考

- [高斯模糊的算法](https://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html)
- [高斯模糊维基百科](https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A)

## Canny 边缘检测

坎尼边缘检测算子是澳洲计算机科学家约翰·坎尼于1986年开发出来的一个多级边缘检测算法。更为重要的是坎尼创立了“边缘检测计算理论”（computational theory of edge detection）解释这项技术如何工作。

### 步骤

1. 消除噪声：使用高斯平滑滤波器卷积降噪。

2. 计算梯度幅值和方向：可选用soble算子、Prewitt算子、Roberts模板等等。这样就可以得图像在x和y方向梯度。

3. 非极大值抑制：非极大值抑制是进行边缘检测的一个重要步骤，通俗意义上是指寻找像素点局部最大值。在每一点上，领域中心x与沿着其对应的梯度方向的两个像素相比，若中心像素为最大值，则保留，否则中心置0，这样可以抑制非极大值，保留局部梯度最大的点，以细化边缘。

4. 滞后阈值(Hysteresis thresholding)：滞后阈值需要两个阈值(高阈值和低阈值)。
在施加非极大值抑制之后，剩余的像素可以更准确地表示图像中的实际边缘。然而，仍然存在由于噪声和颜色变化引起的一些边缘像素。为了解决这些杂散响应，必须用弱梯度值过滤边缘像素，并保留具有高梯度值的边缘像素，可以通过选择高低阈值来实现。

- 如果某一像素位置的幅值超过高阈值，该像素被保留为边缘像素。
- 如果某一像素位置的幅值小于低阈值，该像素被排除。
- 如果某一像素位置的幅值在两个阈值之间，则根据连通性来分类为边缘或者非边缘：该像素与确定为边缘的像素点邻接，则判定为边缘；否则为非边缘。

参考：[Canny边缘检测算法及实现](https://blog.csdn.net/leonardohaig/article/details/122141568)

## 霍夫圆变换

霍夫梯度法的原理

- 估计圆心

1. 把原图做一次 Canny 边缘检测，得到边缘检测的二值图。

2. 对原始图像执行一次 Sobel 算子，计算出所有像素的邻域梯度值。

3. 初始化圆心空间 N(a,b)，令所有的 N(a,b)=0。

4. 遍历 Canny 边缘二值图中的所有非零像素点，沿着梯度方向 ( 切线的垂直方向 )画线，将线段经过的所有累加器中的点 (a,b) 的 N(a,b)+=1。

![点累加](https://github.com/Ouzr0107/picx-images-hosting/raw/master/1760131-20200220000459534-1166499045.73udwqzd6n.png)

5. 统计排序 N(a,b)，得到可能的圆心（N(a,b) 越大，越有可能是圆心）。

![统计排序](https://github.com/Ouzr0107/picx-images-hosting/raw/master/1760131-20200220113249369-1235776308.2h8qw20tj2.png)

- 估计半径（针对某一个圆心 (a,b)）

1. 计算 Canny 图中所有非 0 点距离圆心的距离。

2. 距离从小到大排序，根据阈值，选取合适的可能半径（比如 3 和 3.5 都被划为半径值 3 中）。

3. 初始化半径空间 r, N(r)=0。

4. 遍历 Canny 图中的非 0 点，N( 距离 )+=1。

5. 统计得到可能的半径值（N(r) 越大，说明这个距离值出现次数越多，越有可能是半径值）。

参考：[opencv —— HoughCircles 霍夫圆变换原理及圆检测](https://www.cnblogs.com/bjxqmy/p/12333022.html)

## Sobel 算子

索伯算子（Sobel operator）是图像处理中的算子之一，有时又称为索伯-费尔德曼算子或索伯滤波器，在影像处理及电脑视觉领域中常被用来做边缘检测。

该算子包含两组3x3的矩阵，分别为横向及纵向，将之与图像作平面卷积。如果以
${\displaystyle \mathbf {A} }$ 代表原始图像， ${\displaystyle \mathbf {G_{x}} }$ 及 ${\displaystyle \mathbf {G_{y}} }$ 分别代表经横向及纵向边缘检测的图像，其公式如下：

$$\mathbf{G}_{\mathbf{x}}=\left[\begin{array}{lll}{+1}&{0}&{-1}\\
{+2}&{0}&{-2}\\
{+1}&{0}&{-1}\end{array}\right]*\mathbf{A}\quad\mathrm{and}\quad\mathbf{G}_{\mathbf{y}}=\left[\begin{array}{lll}{+1}&{+2}&{+1}\\
{0}&{0}&{0}\\
{-1}&{-2}&{-1}\end{array}\right]*\mathbf{A}$$

图像的每一个像素的横向及纵向梯度近似值可用以下的公式结合，来计算梯度的大小。

$$\mathbf{G}=\sqrt{\mathbf{G_{x}}^{2}+\mathbf{G_{y}}^{2}}$$

然后可用以下公式计算梯度方向。

$$\mathbf{\Theta}=\arctan\biggl(\frac{\mathbf{G_{y}}}{\mathbf{G_{x}}}\biggr)$$

以纵向边缘为例，如果角度
 ${\displaystyle \Theta }$ 等于零，即代表图像的纵向边缘右方较亮；若为 ${\displaystyle \pi }$ ，则左方较亮。

参考：[索伯算子 wiki](https://zh.wikipedia.org/wiki/%E7%B4%A2%E4%BC%AF%E7%AE%97%E5%AD%90)

## 双边滤波

双边滤波（Bilateral filter）是一种非线性的滤波方法，是结合图像的空间邻近度和像素值相似度的一种折衷处理，同时考虑空域信息和灰度相似性，达到保边去噪的目的。具有简单、非迭代、局部的特点。

双边滤波器的好处是可以做边缘保存（edge preserving），一般用高斯滤波去降噪，会较明显地模糊边缘，对于高频细节的保护效果并不明显。双边滤波器顾名思义比高斯滤波多了一个高斯方差sigma－d，它是基于空间分布的高斯滤波函数，所以在边缘附近，离的较远的像素不会太多影响到边缘上的像素值，这样就保证了边缘附近像素值的保存。但是由于保存了过多的高频信息，对于彩色图像里的高频噪声，双边滤波器不能够干净的滤掉，只能够对于低频信息进行较好的滤波。

权重系数w(i,j,k,l)取决于空间域核d与值域核r的乘积：

空间域核d,表示邻域内某点(k,l)与中心点(i,j)的欧式距离:

$$\mathrm{d(i,j,k,l)=\exp(-\frac{(i-k)^{2}+(j-l)^{2}}{2\sigma_{d}^{2}})},$$

值域核r,表示邻域内某点(k,l)的灰度值f(k,l)与中心点(i,j)灰度值f(i,j)的差的绝对值:

$$\mathrm{r(i,j,k,l)=exp(-\frac{||f(i,j)-f(k,l)||^{2}}{2\sigma_{r}^{2}})},$$

参考：[双边滤波算法原理及代码介绍](https://blog.csdn.net/leonardohaig/article/details/118058527)
